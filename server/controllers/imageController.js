const Scene = require("../models/Scene");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const {
  uploadBase64ToFirebase,
  deleteFromFirebase,
} = require("../utils/uploadToFirebase");

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Style prompts mapping
const stylePrompts = {
  realistic:
    "photorealistic, high quality, detailed, professional photography, 8k resolution",
  anime:
    "anime style, manga art, Japanese animation style, vibrant colors, cel shaded",
  cartoon:
    "cartoon style, animated, colorful, fun illustration, Disney Pixar style",
  painting:
    "oil painting style, artistic, brush strokes, fine art, impressionist",
};

// Helper function to generate image with Gemini AI
const generateImageWithGemini = async (prompt, folder = "scenes") => {
  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-3-pro-image-preview",
    });

    console.log("Generating image with Gemini AI...");
    console.log("Prompt:", prompt);

    const result = await model.generateContent({
      contents: [
        {
          role: "user",
          parts: [{ text: `Generate an image: ${prompt}` }],
        },
      ],
    });

    const response = result.response;
    let imageUrl = "";

    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            const mimeType = part.inlineData.mimeType || "image/png";
            const base64Data = `data:${mimeType};base64,${part.inlineData.data}`;

            console.log("Uploading image to Firebase Storage...");
            imageUrl = await uploadBase64ToFirebase(base64Data, folder);
            break;
          }
        }
      }
    }

    if (!imageUrl) {
      console.log("No image generated by Gemini, using placeholder");
      imageUrl = `https://via.placeholder.com/1024x1024/10b981/ffffff?text=${encodeURIComponent(
        prompt.substring(0, 30)
      )}`;
    }

    return imageUrl;
  } catch (error) {
    console.error("Error in generateImageWithGemini:", error);
    return `https://via.placeholder.com/1024x1024/10b981/ffffff?text=Generation+Failed`;
  }
};

// Helper function to edit image with base image and edit prompt using Gemini AI
const editImageWithGemini = async (
  base64Image,
  originalPrompt,
  editPrompt,
  folder = "scenes"
) => {
  try {
    const model = genAI.getGenerativeModel({
      model: "gemini-3-pro-image-preview",
    });

    console.log("Editing image with Gemini AI...");
    console.log("Original prompt:", originalPrompt);
    console.log("Edit prompt:", editPrompt);

    // Parse base64 image
    const base64Data = base64Image.replace(/^data:image\/\w+;base64,/, "");
    const mimeType =
      base64Image.match(/^data:image\/(\w+);base64,/)?.[1] || "png";

    // Combine original prompt with edit instructions
    const combinedPrompt = editPrompt
      ? `${originalPrompt}. ${editPrompt}. Keep the same subject and composition, only apply the requested changes.`
      : originalPrompt;

    // Prepare parts with both image and text
    const parts = [
      {
        inlineData: {
          data: base64Data,
          mimeType: `image/${mimeType}`,
        },
      },
      {
        text: combinedPrompt,
      },
    ];

    const result = await model.generateContent({
      contents: [
        {
          role: "user",
          parts: parts,
        },
      ],
    });

    const response = result.response;
    let imageUrl = "";

    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            const resultMimeType = part.inlineData.mimeType || "image/png";
            const resultBase64Data = `data:${resultMimeType};base64,${part.inlineData.data}`;

            console.log("Uploading edited image to Firebase Storage...");
            imageUrl = await uploadBase64ToFirebase(resultBase64Data, folder);
            break;
          }
        }
      }
    }

    if (!imageUrl) {
      console.log("No image edited by Gemini, using placeholder");
      imageUrl = `https://via.placeholder.com/1024x1024/10b981/ffffff?text=Edit+Failed`;
    }

    return imageUrl;
  } catch (error) {
    console.error("Error in editImageWithGemini:", error);
    throw new Error(`Failed to edit image: ${error.message}`);
  }
};

// @desc    Generate scene image using Gemini AI
// @route   POST /api/images/generate
// @access  Private
const generateScene = async (req, res) => {
  try {
    const { prompt, style = "realistic", baseImage } = req.body;

    if (!prompt) {
      return res.status(400).json({
        success: false,
        message: "Please provide a prompt",
      });
    }

    const enhancedPrompt = `${prompt}. ${
      stylePrompts[style] || stylePrompts.realistic
    }`;

    // If baseImage is provided, edit existing image; otherwise generate new
    let imageUrl;
    if (baseImage) {
      imageUrl = await editImageWithGemini(baseImage, prompt, "", "scenes");
    } else {
      imageUrl = await generateImageWithGemini(enhancedPrompt, "scenes");
    }

    const scene = await Scene.create({
      user: req.user._id,
      prompt: enhancedPrompt,
      style,
      imageUrl,
      status: "completed",
    });

    res.status(201).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error("Error generating scene:", error);
    res.status(500).json({
      success: false,
      message: "Failed to generate scene",
      error: error.message,
    });
  }
};

// Helper function to convert image URL to base64 on server side
const urlToBase64 = async (url) => {
  try {
    const https = require("https");
    const http = require("http");
    const { URL } = require("url");

    return new Promise((resolve, reject) => {
      const urlObj = new URL(url);
      const client = urlObj.protocol === "https:" ? https : http;

      client
        .get(url, (response) => {
          if (response.statusCode !== 200) {
            reject(new Error(`Failed to fetch image: ${response.statusCode}`));
            return;
          }

          const chunks = [];
          response.on("data", (chunk) => chunks.push(chunk));
          response.on("end", () => {
            const buffer = Buffer.concat(chunks);
            const base64 = buffer.toString("base64");
            const contentType = response.headers["content-type"] || "image/png";
            resolve(`data:${contentType};base64,${base64}`);
          });
        })
        .on("error", reject);
    });
  } catch (error) {
    throw new Error(`Failed to convert URL to base64: ${error.message}`);
  }
};

// @desc    Edit image using Gemini AI
// @route   POST /api/images/edit
// @access  Private
const editImage = async (req, res) => {
  try {
    const {
      baseImage,
      baseImageUrl, // Accept URL as alternative
      originalPrompt,
      editPrompt,
      style = "realistic",
    } = req.body;

    console.log("Edit image request received:", {
      hasBaseImage: !!baseImage,
      hasBaseImageUrl: !!baseImageUrl,
      baseImageLength: baseImage ? baseImage.length : 0,
      baseImageUrl: baseImageUrl ? baseImageUrl.substring(0, 100) : null,
      originalPrompt,
      editPrompt,
      style,
    });

    let imageBase64 = baseImage;

    // If baseImageUrl is provided, convert it to base64 on server
    if (!imageBase64 && baseImageUrl) {
      try {
        console.log("Converting image URL to base64 on server:", baseImageUrl);
        imageBase64 = await urlToBase64(baseImageUrl);
        console.log("Successfully converted URL to base64");
      } catch (urlError) {
        console.error("Error converting URL to base64:", urlError);
        return res.status(400).json({
          success: false,
          message: `Failed to load image from URL: ${urlError.message}`,
        });
      }
    }

    if (!imageBase64) {
      return res.status(400).json({
        success: false,
        message: "Please provide a base image (baseImage or baseImageUrl)",
      });
    }

    if (!editPrompt || !editPrompt.trim()) {
      return res.status(400).json({
        success: false,
        message: "Please provide edit instructions",
      });
    }

    console.log(
      "Calling editImageWithGemini with imageBase64 length:",
      imageBase64 ? imageBase64.length : 0
    );

    // Edit image with Gemini AI
    const imageUrl = await editImageWithGemini(
      imageBase64,
      originalPrompt || "",
      editPrompt.trim(),
      "scenes"
    );

    console.log("Image edited successfully, URL:", imageUrl);

    // Save edited image to Scene model
    const scene = await Scene.create({
      user: req.user._id,
      prompt: editPrompt.trim(),
      style,
      imageUrl,
      status: "completed",
    });

    console.log("Scene saved successfully:", scene._id);

    res.status(201).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error("Error editing image:", error);
    res.status(500).json({
      success: false,
      message: "Failed to edit image",
      error: error.message,
    });
  }
};

// @desc    Get user's scenes
// @route   GET /api/images/scenes
// @access  Private
const getUserScenes = async (req, res) => {
  try {
    const scenes = await Scene.find({ user: req.user._id }).sort({
      createdAt: -1,
    });

    res.status(200).json({
      success: true,
      count: scenes.length,
      data: scenes,
    });
  } catch (error) {
    console.error("Error fetching scenes:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch scenes",
      error: error.message,
    });
  }
};

// @desc    Get single scene
// @route   GET /api/images/scenes/:id
// @access  Private
const getScene = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({
        success: false,
        message: "Scene not found",
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to access this scene",
      });
    }

    res.status(200).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error("Error fetching scene:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch scene",
      error: error.message,
    });
  }
};

// @desc    Delete scene
// @route   DELETE /api/images/scenes/:id
// @access  Private
const deleteScene = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({
        success: false,
        message: "Scene not found",
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to delete this scene",
      });
    }

    if (scene.imageUrl && scene.imageUrl.includes("storage.googleapis.com")) {
      await deleteFromFirebase(scene.imageUrl);
    }

    await scene.deleteOne();

    res.status(200).json({
      success: true,
      message: "Scene deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting scene:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete scene",
      error: error.message,
    });
  }
};

// @desc    Toggle favorite scene
// @route   PUT /api/images/scenes/:id/favorite
// @access  Private
const toggleFavorite = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({
        success: false,
        message: "Scene not found",
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to modify this scene",
      });
    }

    scene.isFavorite = !scene.isFavorite;
    await scene.save();

    res.status(200).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error("Error toggling favorite:", error);
    res.status(500).json({
      success: false,
      message: "Failed to toggle favorite",
      error: error.message,
    });
  }
};

// @desc    Get trending images
// @route   GET /api/images/trending
// @access  Public
const getTrending = async (req, res) => {
  try {
    const trending = await Scene.find({ status: "completed" })
      .sort({ createdAt: -1 })
      .limit(20)
      .populate("user", "username");

    res.status(200).json({
      success: true,
      count: trending.length,
      data: trending,
    });
  } catch (error) {
    console.error("Error fetching trending:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch trending images",
      error: error.message,
    });
  }
};

module.exports = {
  generateScene,
  editImage,
  getUserScenes,
  getScene,
  deleteScene,
  toggleFavorite,
  getTrending,
};
