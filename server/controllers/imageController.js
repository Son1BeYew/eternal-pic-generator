const Scene = require('../models/Scene');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { uploadBase64ToFirebase, deleteFromFirebase } = require('../utils/uploadToFirebase');

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Style prompts mapping
const stylePrompts = {
  realistic: 'photorealistic, high quality, detailed, professional photography, 8k resolution',
  anime: 'anime style, manga art, Japanese animation style, vibrant colors, cel shaded',
  cartoon: 'cartoon style, animated, colorful, fun illustration, Disney Pixar style',
  painting: 'oil painting style, artistic, brush strokes, fine art, impressionist',
};

// Helper function to generate image with Gemini AI
const generateImageWithGemini = async (prompt, folder = 'scenes') => {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-3-pro-image-preview' });

    console.log('Generating image with Gemini AI...');
    console.log('Prompt:', prompt);

    const result = await model.generateContent({
      contents: [{
        role: 'user',
        parts: [{ text: `Generate an image: ${prompt}` }]
      }]
    });

    const response = result.response;
    let imageUrl = '';

    if (response.candidates && response.candidates[0]) {
      const candidate = response.candidates[0];
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.inlineData && part.inlineData.data) {
            const mimeType = part.inlineData.mimeType || 'image/png';
            const base64Data = `data:${mimeType};base64,${part.inlineData.data}`;
            
            console.log('Uploading image to Firebase Storage...');
            imageUrl = await uploadBase64ToFirebase(base64Data, folder);
            break;
          }
        }
      }
    }

    if (!imageUrl) {
      console.log('No image generated by Gemini, using placeholder');
      imageUrl = `https://via.placeholder.com/1024x1024/10b981/ffffff?text=${encodeURIComponent(prompt.substring(0, 30))}`;
    }

    return imageUrl;
  } catch (error) {
    console.error('Error in generateImageWithGemini:', error);
    return `https://via.placeholder.com/1024x1024/10b981/ffffff?text=Generation+Failed`;
  }
};

// @desc    Generate scene image using Gemini AI
// @route   POST /api/images/generate
// @access  Private
const generateScene = async (req, res) => {
  try {
    const { prompt, style = 'realistic' } = req.body;

    if (!prompt) {
      return res.status(400).json({ 
        success: false,
        message: 'Please provide a prompt' 
      });
    }

    const enhancedPrompt = `${prompt}. ${stylePrompts[style] || stylePrompts.realistic}`;
    const imageUrl = await generateImageWithGemini(enhancedPrompt, 'scenes');

    const scene = await Scene.create({
      user: req.user._id,
      prompt: enhancedPrompt,
      style,
      imageUrl,
      status: 'completed',
    });

    res.status(201).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error('Error generating scene:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to generate scene',
      error: error.message 
    });
  }
};

// @desc    Get user's scenes
// @route   GET /api/images/scenes
// @access  Private
const getUserScenes = async (req, res) => {
  try {
    const scenes = await Scene.find({ user: req.user._id }).sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: scenes.length,
      data: scenes,
    });
  } catch (error) {
    console.error('Error fetching scenes:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch scenes',
      error: error.message 
    });
  }
};

// @desc    Get single scene
// @route   GET /api/images/scenes/:id
// @access  Private
const getScene = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({ 
        success: false,
        message: 'Scene not found' 
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({ 
        success: false,
        message: 'Not authorized to access this scene' 
      });
    }

    res.status(200).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error('Error fetching scene:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch scene',
      error: error.message 
    });
  }
};

// @desc    Delete scene
// @route   DELETE /api/images/scenes/:id
// @access  Private
const deleteScene = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({ 
        success: false,
        message: 'Scene not found' 
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({ 
        success: false,
        message: 'Not authorized to delete this scene' 
      });
    }

    if (scene.imageUrl && scene.imageUrl.includes('storage.googleapis.com')) {
      await deleteFromFirebase(scene.imageUrl);
    }

    await scene.deleteOne();

    res.status(200).json({
      success: true,
      message: 'Scene deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting scene:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to delete scene',
      error: error.message 
    });
  }
};

// @desc    Toggle favorite scene
// @route   PUT /api/images/scenes/:id/favorite
// @access  Private
const toggleFavorite = async (req, res) => {
  try {
    const scene = await Scene.findById(req.params.id);

    if (!scene) {
      return res.status(404).json({ 
        success: false,
        message: 'Scene not found' 
      });
    }

    if (scene.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({ 
        success: false,
        message: 'Not authorized to modify this scene' 
      });
    }

    scene.isFavorite = !scene.isFavorite;
    await scene.save();

    res.status(200).json({
      success: true,
      data: scene,
    });
  } catch (error) {
    console.error('Error toggling favorite:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to toggle favorite',
      error: error.message 
    });
  }
};

// @desc    Get trending images
// @route   GET /api/images/trending
// @access  Public
const getTrending = async (req, res) => {
  try {
    const trending = await Scene.find({ status: 'completed' })
      .sort({ createdAt: -1 })
      .limit(20)
      .populate('user', 'username');

    res.status(200).json({
      success: true,
      count: trending.length,
      data: trending,
    });
  } catch (error) {
    console.error('Error fetching trending:', error);
    res.status(500).json({ 
      success: false,
      message: 'Failed to fetch trending images',
      error: error.message 
    });
  }
};

module.exports = {
  generateScene,
  getUserScenes,
  getScene,
  deleteScene,
  toggleFavorite,
  getTrending,
};
